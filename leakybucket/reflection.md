# v1.0

## 算法层面
虽然联系实际情况来看，只要漏桶中有水，底部就不断有水滴滴出，但我们不需要真的去模拟这个过程。漏桶算法是为了限流、整形的，其根本目的是在一个请求到来时，判断这个请求是否可以被接受。我们可以从”一段时间“的角度来考虑某一段时间内一共漏出去多少。漏桶的速率是一定的，那么某段时间内可以处理的请求数量就可以计算得出。当一个请求到达时，我们只需计算从此时到上一次”漏水“的时段内，漏桶一共可以漏出去多少水，进而更新漏桶的当前容量。如果剩下的容量足够处理请求，就给予通过。

漏水速率和计算elapsed的精度应该是什么？秒级还是毫秒？根据业务需求而决定，这里我就使用秒。

漏桶算法用一个“固定速率泄漏”的机制，把动态、突发的请求行为转化成“阶段性处理”的稳定过程，从而实现限流控制。这种思维方式确实可以理解为对动态问题的阶段性静态模拟。


## Golang层面
1. Golang没有面向对象的说法，用结构体struct和接收者来模拟面向对象。在Python中有class，里面定义了属性和方法，构造函数就是__init__，但是在Go中，属性定义在struct里，相应的方法用接受者的模式单独定义，实例化srtuct也最好也是单独放在一个函数（构造函数）里。
2. 类型是放在变量名后面的，比如struct中是“variable_name type"
3. 导入包，永远是import("")，哪怕只导入一个package也要用括号和双引号
4. 函数名可以是aaaBbb这样的：^(_|[a-zA-Z0-9]+)$
5. 接受者函数的(sn *structName)是紧跟在funcs后面的，而且一定要写上一个structName的缩写，这样就通过缩写.属性的方式进行使用
6. :=
7. Golang是严格类型，函数如果有返回值，一定要在生命中写清楚返回类型
8. 结构体初始化的时候，最后一个field后面也要写上逗号
9. for循环的条件里，是用分号，不是Python那样用逗号
10. 加锁是用sync.Mutex